#!/bin/bash
source ~/git-completion.bash

#fancy LS colors
export LS_COLORS='no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:su=37;41:sg=30;43:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.svgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.lzma=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.rar=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:'

if [[ $COLORTERM = gnome-* && $TERM = xterm ]] && infocmp gnome-256color >/dev/null 2>&1; then
        export TERM=gnome-256color
elif infocmp xterm-256color >/dev/null 2>&1; then
        export TERM=xterm-256color
fi

if tput setaf 1 &> /dev/null; then
	tput sgr0
	if [[ $(tput colors) -ge 256 ]] 2>/dev/null; then
		MAGENTA=$(tput setaf 9)
		ORANGE=$(tput setaf 172)
		GREEN=$(tput setaf 190)
		PURPLE=$(tput setaf 141)
		WHITE=$(tput setaf 0)
		BLUE=$(tput setaf 75)
	else
		MAGENTA=$(tput setaf 5)
		ORANGE=$(tput setaf 4)
		GREEN=$(tput setaf 2)
		PURPLE=$(tput setaf 1)
		WHITE=$(tput setaf 7)
	fi
	BOLD=$(tput bold)
	RESET=$(tput sgr0)
else
	MAGENTA="\033[1;31m"
	ORANGE="\033[1;33m"
	GREEN="\033[1;32m"
	PURPLE="\033[1;35m"
	WHITE="\033[1;37m"
	BOLD=""
	RESET="\033[m"
fi

export MAGENTA
export ORANGE
export GREEN
export PURPLE
export WHITE
export BLUE
export BOLD
export RESET

# checkout branch by grep basically
gk () {
  match="$1"
  index=$2
  if [ -z $match ]
  then
    echo please provide a string to match for branch checkout - also pass index if multiple exist
    return
  fi

  local_matches=(`git branch | sed -E 's/(\* |  )//' | grep $match | sort -u`)
  matches=(`git branch -a | sed -E 's/(\* |  |  remotes\/(origin|upstream)\/)//' | grep $match | sort -u`)

  # if master checkout master
  if [ $match = "master" ]
  then
    git checkout master

  # checkout if only one local match
  elif [ "${#local_matches[@]}" -eq 1 ]
  then
    git checkout ${local_matches[0]}

  # checkout if only one match
  elif [ "${#matches[@]}" -eq 1 ]
  then
    git checkout ${matches[0]}

  # checkout by index if given
  elif [ ! -z "$index" ]
  then
    git checkout ${matches[$index]}

  # else 
  else
    for ((i=0; i<${#matches[@]};i++))
    do
      echo ${matches[$i]}
    done
  fi
}

_gk () {
  local cur prev opts
  COMPREPLY=()
  cur="${COMP_WORDS[COMP_CWORD]}"
  if [ -z "$cur" ]
  then
    opts="$(git branch | sed 's/\*//')"
  else
    opts="$(git branch | sed 's/\*//' | grep -Eo "$cur.*$" )"
  fi
  COMPREPLY=($(compgen -W "${opts}" ${cur}))
  return 0
}

complete -F _gk gk

# reload chrome
rechrome () {
  osascript -e 'activate application "Google Chrome"'
  osascript -e 'tell application "System Events" to keystroke "r" using {command down}'
}

# open a node stack trace in vim
stacktrace () {
  files=""
  paste=`pbpaste`
  cmd="set statusline=%F | set laststatus=2 | copen"
  cur_dir="${PWD##*/}"

  while read -r line
  do
    file=`echo $line | awk "{gsub(/^.+$cur_dir\//, \"\"); gsub(/:.+$/, \"\")}1"`
    linenumber=`echo $line | sed -E 's/^.*:([0-9]+):.*/\1/'`
    col=`echo $line | awk '{gsub(/.+:/, ""); gsub(/[).]*$/, "")}1'`
    files="$files {\"filename\":\"$file\", \"lnum\": $linenumber, \"col\": $col},"
  done <<< "$paste"

  cmd="call setqflist([$files]) | $cmd"

  vim -c "$cmd"
}

# open all the changed files in the working tree
viff () {
  diff=$1
  input="`git diff $diff --name-only` `git diff $diff --name-only --cached`"
  files=""

  while read -r line
  do
    files="$files {\"filename\":\"$line\", \"lnum\":1},"
  done <<< "$input"

  vim -c "call setqflist([$files]) | copen"
}

# serves README or specified file and opens it in the browser
gread () {
  open "http://localhost:6419"
  grip "$1"
}

# merge in latest master brance (I know mastermerge would be more accurate, but less funny)
masterbase () {
  dirty=$(git diff)
  branch=`git branch | grep '*' | awk '{print $(NF)}'`
  upstream=`git remote show | grep upstream`

  # stash if we need to
  if [ ! -z "$dirty" ]
  then
    git stash
  fi

  # get master
  git checkout master
  git pull

  # fetch and merge upstream if we have it
  if [ ! -z "$upstream" ]
  then
    git fetch upstream
    git merge upstream/master
  fi

  # merge master
  git checkout $branch
  git merge master

  # re-apply stash if necessary
  if [ ! -z "$dirty" ]
  then
    git stash apply
  fi
}

# open conflicts in vim
miff () {
  diff=$1
  input=`git status | grep 'both modified' | awk '{print $(NF)}'`
  files=""

  while read -r line
  do
    files="$files {\"filename\":\"$line\", \"lnum\":1},"
  done <<< "$input"

  vim -c "call setqflist([$files]) | copen"
}

pyserv () {
  if [ ! -z "$1" ]
  then
    PORT=$1
  else
    PORT=8000
  fi

  echo $PORT
  echo "http://localhost:$PORT"

  python -m SimpleHTTPServer $PORT & open "http://localhost:$PORT"
}

# Git branch in prompt.

parse_git_branch() {
  branch=`git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/(\1)/'`
  BPSO=`echo $branch | grep -oE 'BPSO-\d+'`

	if [ -z $branch ]
  then
    echo " "
  elif [ -z $BPSO ]
  then
    echo "$branch"
  else
    echo "($BPSO)"
  fi
}

export PS1="\[\033[32m\]\u@$(echo $HOSTNAME | sed 's/-.*$//'):\[\033[00m\]\w/\[\033[94m\]\$(parse_git_branch)\[\033[00m\]$ "


gogo () {
  path="$HOME"
  for i in $@
  do
    path="$path/$i"
  done

  cd $path
}

_gogo() 
{
  local cur prev opts
  COMPREPLY=()
  cur="${COMP_WORDS[COMP_CWORD]}"
  prev="${COMP_WORDS[COMP_CWORD - 1]}"
  if [ "$prev" = "go" ]
  then
    opts="dev woodshop"
  else
    path="$HOME/$(join / ${COMP_WORDS[@]:1:${#COMP_WORDS[@]}-2})/*/"
    opts="$(ls -d $path | sed -E 's/\/$//' | sed -E 's/^.*\///' | xargs echo)"
  fi

  COMPREPLY=($(compgen -W "${opts}" ${cur}))
  return 0
}
complete -F _gogo gogo

# read from stdin or passed in list of filenames and open in vim
viml () {
  # set some options
  cmd="set modifiable | set statusline=%F | set laststatus=2 | copen"
  qflist=""

  # if we've been passed args (stdin is empty)
  if [ -t 0 ]
  then
    for file in "$@"
    do
      # add current working dir to relative paths
      if [ -z $(echo "$file" | grep "^\/") ]
      then
        file="$(pwd)/$file"
      fi

      # linenumber
      nums=( $(echo "$file" | grep -o ':[0-9][0-9]*' | sed 's/://g') )
      lnum=${nums[0]}
      cnum=${nums[1]}
      if [ -z "$cnum" ]
      then
        cnum=1
      fi

      if [ -z "$lnum" ]
      then
        lnum=1
      fi

      # strip extras from file
      file=$(echo $file | sed 's/:.*$//')

      # add to quickfix list for vim
      qflist="$qflist {\"filename\":\"$file\", \"lnum\": $lnum, \"col\": $cnum},"
    done

    # set command and open quickfix list in vim
    cmd="call setqflist([$qflist]) | $cmd"
    vim -c "$cmd"

  # if we're taking stdin
  else
    while read file
    do
      # add current working dir to relative paths
      if [ -z $(echo "$file" | grep "^\/") ]
      then
        file="$(pwd)/$file"
      fi

      # linenumber
      nums=( $(echo "$file" | grep -o ':[0-9][0-9]*' | sed 's/://g') )
      lnum=${nums[0]}
      cnum=${nums[1]}
      if [ -z "$cnum" ]
      then
        cnum=1
      fi

      if [ -z "$lnum" ]
      then
        lnum=1
      fi

      # strip extras from file
      file=$(echo $file | sed 's/:.*$//')

      # add to quickfix list for vim
      qflist="$qflist {\"filename\":\"$file\", \"lnum\": $lnum, \"col\": $cnum},"
    done

    # set command and open quickfix list in vim (passing - to let vim know we're coming from stdin)
    cmd="call setqflist([$qflist]) | $cmd"
    vim - -c "$cmd"
  fi
}

# List files starting with ., but not implied ., .. Don't print group
# Use custom colors as outlined by LS_COLORS
alias lsg='ls -AGloh'
# alias for getting top cpu users
alias psc='ps aux -cr | head'
# alias for getting top memory users
alias psm='ps aux -cm | head'
alias postgresser='postgres -D /usr/local/var/postgres'
alias crosscomp='export PATH="$HOME/opt/cross/bin:$PATH"'
alias mycom='sudo /Library/StartupItems/MySQLCOM/MySQLCOM'
alias sub='open -a "Sublime Text"'
alias phpserv='sudo apachectl -d $PWD -k start && open http://localhost'
alias phpstop='sudo apachectl -d $PWD -k stop'
alias status='clear; git branch -vv; git status'
alias gdiff='git diff --color=always | less -r'
alias commit='git add -A; git commit'
alias commend='git add -A; git commit --amend'
alias nerd='vim -c Nerd'
export TERM='xterm-256color'

platform=`uname`
if [ "$platform" != "Linux" ]
then
  for f in /etc/bash_completion.d/*; do source $f; done

  # Automatically add completion for all aliases to commands having completion functions
  function alias_completion {
      local namespace="alias_completion"

      # parse function based completion definitions, where capture group 2 => function and 3 => trigger
      local compl_regex='complete( +[^ ]+)* -F ([^ ]+) ("[^"]+"|[^ ]+)'
      # parse alias definitions, where capture group 1 => trigger, 2 => command, 3 => command arguments
      local alias_regex="alias ([^=]+)='(\"[^\"]+\"|[^ ]+)(( +[^ ]+)*)'"

      # create array of function completion triggers, keeping multi-word triggers together
      eval "local completions=($(complete -p | sed -Ene "/$compl_regex/s//'\3'/p"))"
      (( ${#completions[@]} == 0 )) && return 0

      # create temporary file for wrapper functions and completions
      rm -f "/tmp/${namespace}-*.tmp" # preliminary cleanup
      local tmp_file="$(mktemp "/tmp/${namespace}-${RANDOM}.tmp")" || return 1

      # read in "<alias> '<aliased command>' '<command args>'" lines from defined aliases
      local line; while read line; do
          eval "local alias_tokens=($line)" 2>/dev/null || continue # some alias arg patterns cause an eval parse error 
          local alias_name="${alias_tokens[0]}" alias_cmd="${alias_tokens[1]}" alias_args="${alias_tokens[2]# }"

          # skip aliases to pipes, boolan control structures and other command lists
          # (leveraging that eval errs out if $alias_args contains unquoted shell metacharacters)
          eval "local alias_arg_words=($alias_args)" 2>/dev/null || continue

          # skip alias if there is no completion function triggered by the aliased command
          [[ " ${completions[*]} " =~ " $alias_cmd " ]] || continue
          local new_completion="$(complete -p "$alias_cmd")"

          # create a wrapper inserting the alias arguments if any
          if [[ -n $alias_args ]]; then
              local compl_func="${new_completion/#* -F /}"; compl_func="${compl_func%% *}"
              # avoid recursive call loops by ignoring our own functions
              if [[ "${compl_func#_$namespace::}" == $compl_func ]]; then
                  local compl_wrapper="_${namespace}::${alias_name}"
                      echo "function $compl_wrapper {
                          (( COMP_CWORD += ${#alias_arg_words[@]} ))
                          COMP_WORDS=($alias_cmd $alias_args \${COMP_WORDS[@]:1})
                          $compl_func
                      }" >> "$tmp_file"
                      new_completion="${new_completion/ -F $compl_func / -F $compl_wrapper }"
              fi
          fi

          # replace completion trigger by alias
          new_completion="${new_completion% *} $alias_name"
          echo "$new_completion" >> "$tmp_file"
      done < <(alias -p | sed -Ene "s/$alias_regex/\1 '\2' '\3'/p")
      source "$tmp_file" && rm -f "$tmp_file"
  }; alias_completion
fi

if [ "$platform" = "Linux" ]
then
  setxkbmap -option ctrl:swapcaps
  alias pbcopy="xclip -selection clipboard"
  alias pbpaste="xclip -o -selection clipboard"
fi

export VISUAL=vim
export EDITOR="$VISUAL"
export CLUTCH_ENV=test
set -o vi

export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

source ~/notes/notes

source ~/.rcconfig
source ~/.avrsrc
source ~/.cienarc
source ~/.clutchrc
